<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Tower Defense</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: #1a1a1a;
            color: #ecf0f1;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            /* Permite el desplazamiento si el contenido excede el tamaÃ±o de la pantalla */
            overflow-y: auto;
            min-height: 100vh;
            /* Hace que el texto no sea seleccionable */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        h1 {
            color: #3498db;
            margin-bottom: 10px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 10px;
            width: fit-content;
            /* Se asegura de que el contenedor se expanda segÃºn sea necesario */
            max-width: 100%;
        }

        #game-canvas {
            background-color: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            width: 800px;
            height: 440px;
            max-width: 100%;
            height: auto;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-controls button {
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            color: white;
            background: linear-gradient(145deg, #2980b9, #3498db);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .game-controls button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            box-shadow: none;
        }

        .game-controls button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 6px 6px 10px rgba(0, 0, 0, 0.4);
        }

        .game-info {
            display: flex;
            gap: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-info p {
            margin: 0;
            padding: 3px 10px;
            background-color: #34495e;
            border-radius: 5px;
        }
        
        #game-messages {
            color: #f1c40f;
            font-weight: bold;
            height: 20px;
            margin-top: 10px;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }

            .game-controls {
                flex-direction: column;
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
            }

            .game-controls button, .game-info p {
                width: 100%;
                text-align: center;
            }
        }
    
        /* --- HUD & Sound Toggle --- */
        .hud-top{
            width: 800px;
            max-width: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 6px;
        }
        .sound-btn{ left: -64px;
            position: absolute;
            left: -64px;
            top: 0;
            width: 44px;
            height: 44px;
            border-radius: 10px;
            border: none;
            background: #2e5a3c;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,.3);
        }
        .sound-btn.muted{ background:#546e7a; }
        .heroes-panel{
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 8px 10px;
            display: grid;
            grid-template-columns: repeat(6, minmax(90px,1fr));
            gap: 6px 8px;
            width: calc(100% - 56px);
        }
        .hero-pill{
            display:flex;
            align-items:center;
            justify-content:center;
            gap:2px;
            font-size:.8em;
            background: rgba(0,0,0,0.25);
            border:1px solid rgba(255,255,255,0.12);
            border-radius:10px;
            padding:6px 4px;
            white-space:nowrap;
            transition: all 0.2s ease;
            min-height: 28px;
            overflow: hidden;
        }
        .hero-pill:hover{
            background: rgba(52, 152, 219, 0.3);
            border-color: rgba(52, 152, 219, 0.5);
            transform: translateY(-1px);
        }
        .hero-pill .name{ 
            font-weight:600; 
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .hero-pill .lvl{ 
            opacity:.85; 
            font-size:.85em; 
            flex-shrink: 0;
        }

    
        .speed-controls{
            display:inline-flex;
            gap:4px;
            margin-left:10px;
        }
        .speed-btn{
            background:#2e5a3c;
            color:#fff;
            border:none;
            padding:4px 8px;
            border-radius:6px;
            cursor:pointer;
            font-weight:bold;
        }
        .speed-btn.active{
            background:#4caf50;
        }

        /* Acelerador de velocidad */
        .speed-accelerator {
            position: absolute;
            right: -100px;
            top: 0;
            display: flex;
            gap: 4px;
        }
        .speed-accel-btn {
            background: #2e5a3c;
            color: #fff;
            border: none;
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
        }
        .speed-accel-btn.active {
            background: #4caf50;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud-top">
            <button id="sound-toggle" class="sound-btn" title="Toggle sound">ðŸ”Š</button>
            <div class="heroes-panel" id="heroes-panel">
                <!-- Filled by JS with 12 heroes -->
            </div>
            <div class="speed-accelerator">
                <button class="speed-accel-btn active" data-speed="1">x1</button>
                <button class="speed-accel-btn" data-speed="3">x3</button>
                <button class="speed-accel-btn" data-speed="5">x5</button>
            </div>
        </div>

        <h1>Tower Defense</h1>
        <div class="game-info">
            <p>Points: <span id="gold-value">100</span></p>
            <p>Castle Health: <span id="health-value">100</span></p>
            <p>Wave: <span id="round-value">0</span></p>
        </div>
        <canvas id="game-canvas" width="800" height="440"></canvas>
        <audio id="arrowSound" src="arrow.mp3" preload="auto"></audio>
        <div class="game-controls">
            <button id="pause-btn" disabled>Pause Wave</button>
            <button id="start-round-btn">Start Wave</button>
            <button id="restart-btn">Restart</button>
        </div>
        <p id="game-messages"></p>
    </div>

    <script>
        // Obtener elementos del DOM
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const goldValueEl = document.getElementById('gold-value');
        const healthValueEl = document.getElementById('health-value');
        const roundValueEl = document.getElementById('round-value');
        const startRoundBtn = document.getElementById('start-round-btn');
        const restartBtn = document.getElementById('restart-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const gameMessagesEl = document.getElementById('game-messages');

        let gameSpeed = 1;

        // Event listeners para el acelerador de velocidad
        document.querySelectorAll('.speed-accel-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.speed-accel-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSpeed = parseInt(btn.dataset.speed);
            });
        });

        // Guardar referencia de update original y envolverlo
        const originalUpdate = update;
        update = function(){
            for(let i=0;i<gameSpeed;i++){
                originalUpdate();
            }
        }


        // ---- Heroes data (12) and render HUD ----
        let heroes = Array.from({length:12}).map((_,i)=>({ name:`Hero${i+1}`, level: 1 }));
        
        // Escuchar mensajes del padre para recibir datos de hÃ©roes
        window.addEventListener('message', function(event) {
            if (event.data.type === 'TOWER_DEFENSE_HEROES') {
                heroes = event.data.heroes;
                renderHeroes();
            }
        });
        
        function renderHeroes(){
            const panel = document.getElementById('heroes-panel');
            if(!panel) return;
            panel.innerHTML = heroes.map((h, i) => {
                const fullName = `${h.name} (Lv ${h.level})`;
                const displayName = h.name.length > 8 ? h.name.substring(0, 8) + '...' : h.name;
                
                return `<div class="hero-pill" title="${fullName}">
                    <span class="name">${displayName}</span> 
                    <span class="lvl">(Lv ${h.level})</span>
                </div>`;
            }).join('');
        }
        renderHeroes();

        // ---- Sound toggle ----
        let soundEnabled = true;
        const soundBtn = document.getElementById('sound-toggle');
        function updateSoundUI(){
            soundBtn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            soundBtn.classList.toggle('muted', !soundEnabled);
        }
        soundBtn.addEventListener('click', ()=>{
            soundEnabled = !soundEnabled;
            const base = document.getElementById('arrowSound');
            if(base){ base.muted = !soundEnabled; }
            updateSoundUI();
        });
        updateSoundUI();


        // ---- Audio unlock on first user interaction ----
        window.addEventListener('pointerdown', () => {
            const base = document.getElementById('arrowSound');
            if (base) {
                base.muted = false;
                base.volume = 0.8;
                base.play().then(() => {
                    base.pause();
                    base.currentTime = 0;
                }).catch(() => {});
            }
        }, { once: true });


        // Constantes del juego
        const TILE_SIZE = 40;
        const GRID_COLS = canvas.width / TILE_SIZE;
        const GRID_ROWS = canvas.height / TILE_SIZE;
        const MAX_TOWERS = 12;

        // Estado del juego
        let gold = 0;
        let health = 100;
        let round = 0;
        let roundInProgress = false;

        // Arrays para almacenar los objetos del juego
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let path = [];
        let spawnInterval;
        let isGameOver = false;
        let isPaused = false;

        // --- Clases de los objetos del juego ---

        class Tower {
            constructor(x, y, isTop, heroIndex = 0) {
                this.x = x * TILE_SIZE;
                this.y = y * TILE_SIZE;
                this.width = TILE_SIZE;
                this.height = TILE_SIZE * 1.5; // La torre es un 50% mÃ¡s alta
                this.isTop = isTop;
                this.range = 120;
                this.attackSpeed = 700; // milisegundos entre disparos
                this.damage = 10;
                this.lastShot = 0;
                this.heroIndex = heroIndex; // Ãndice del hÃ©roe asociado a esta torre
            }

            draw() {
                let drawY = this.y;
                // Si la torre estÃ¡ arriba, se dibuja hacia arriba
                if (this.isTop) {
                    drawY = this.y - (this.height - this.width);
                }
                
                // Dibujar imagen del hÃ©roe si estÃ¡ disponible
                const hero = heroes[this.heroIndex];
                if (hero && hero.avatar) {
                    // Intentar dibujar la imagen si ya estÃ¡ cargada
                    try {
                        // Buscar la imagen en el cache o crearla
                        if (!this.heroImage) {
                            this.heroImage = new Image();
                            this.heroImage.src = hero.avatar;
                        }
                        
                        if (this.heroImage.complete) {
                            // Dibujar la imagen del hÃ©roe
                            ctx.save();
                            ctx.globalAlpha = 0.9;
                            ctx.drawImage(this.heroImage, this.x, drawY, this.width, this.height);
                            ctx.restore();
                        } else {
                            // Si la imagen no estÃ¡ cargada, dibujar rectÃ¡ngulo blanco temporal
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2;
                            ctx.fillRect(this.x, drawY, this.width, this.height);
                            ctx.strokeRect(this.x, drawY, this.width, this.height);
                        }
                    } catch (e) {
                        // Fallback: rectÃ¡ngulo blanco
                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.fillRect(this.x, drawY, this.width, this.height);
                        ctx.strokeRect(this.x, drawY, this.width, this.height);
                    }
                } else {
                    // Fallback: rectÃ¡ngulo con color del hÃ©roe o blanco por defecto
                    const heroColor = hero ? `hsl(${(hero.id * 137.5) % 360}, 70%, 60%)` : 'white';
                    ctx.fillStyle = heroColor;
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    
                    ctx.fillRect(this.x, drawY, this.width, this.height);
                    ctx.strokeRect(this.x, drawY, this.width, this.height);
                    
                    // Mostrar inicial del nombre del hÃ©roe
                    if (hero && hero.name) {
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(hero.name.charAt(0).toUpperCase(), this.x + this.width/2, drawY + this.height/2 + 4);
                    }
                }
            }

            update() {
                // Si la ronda no estÃ¡ en progreso, no dispares
                if (!roundInProgress) return;

                // Encontrar un enemigo en rango
                const target = enemies.find(enemy => {
                    const dx = (enemy.x + enemy.size / 2) - (this.x + this.width / 2);
                    const dy = (enemy.y + enemy.size / 2) - (this.y + this.width / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= this.range;
                });

                if (target && Date.now() - this.lastShot > this.attackSpeed) {
                    this.attackProjectile(target);
                    this.lastShot = Date.now();
                }
            }

            attack(enemy) {
                enemy.health -= this.damage;
                if (enemy.health <= 0) {
                    // Eliminar enemigo y dar oro
                    const index = enemies.indexOf(enemy);
                    if (index > -1) {
                        enemies.splice(index, 1);
                        gold += 1;
                        updateUI();
                        // Comprobar si la ronda ha terminado
                        if (enemies.length === 0) {
                            endRound();
                        }
                    }
                }
            }
        }

        
        // Add projectile-based attack without touching original class structure
        Tower.prototype.attackProjectile = function(enemy) {
            const cx = this.x + this.width / 2;
            const cy = (this.isTop ? (this.y - (this.height - this.width)) : this.y) + this.height / 2;
            projectiles.push(new Projectile(cx, cy, enemy, this.damage));
            try {
                const snd = document.getElementById('arrowSound');
                if (snd) { snd.currentTime = 0; snd.play().catch(()=>{}); }
            } catch(e) {}
        };
class Enemy {
            constructor(path) {
                this.path = path;
                this.pathIndex = 0;
                this.x = path[0].x * TILE_SIZE;
                this.y = path[0].y * TILE_SIZE;
                this.size = TILE_SIZE * 0.8;
                this.speed = 0.5;
                this.health = 50 + (round * 5); // Salud aumenta con la ronda
                this.maxHealth = this.health;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`; // Color aleatorio
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);

                // Barra de vida
                const healthBarWidth = (this.health / this.maxHealth) * this.size;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 10, this.size, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x, this.y - 10, healthBarWidth, 5);
            }

            update() {
                if (this.pathIndex < this.path.length - 1) {
                    const nextTile = this.path[this.pathIndex + 1];
                    const targetX = nextTile.x * TILE_SIZE;
                    const targetY = nextTile.y * TILE_SIZE;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > this.speed) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    } else {
                        this.x = targetX;
                        this.y = targetY;
                        this.pathIndex++;
                    }
                } else {
                    // LlegÃ³ al final, daÃ±amos el castillo
                    health -= 10;
                    updateUI();
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    // Comprobar si la ronda ha terminado o el juego ha terminado
                    if (health <= 0) {
                        gameOver();
                    } else if (enemies.length === 0) {
                        endRound();
                    }
                }
            }
        }

        
        class Projectile {
            constructor(sx, sy, target, damage) {
                this.x = sx;
                this.y = sy;
                this.target = target;
                this.damage = damage;
                this.speed = 2.0;
                this.radius = 4;
            }
            update() {
                if (!enemies.includes(this.target)) return 'remove';
                const tx = this.target.x + this.target.size / 2;
                const ty = this.target.y + this.target.size / 2;
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > this.speed) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                    return;
                }
                this.target.health -= this.damage;
                if (this.target.health <= 0) {
                    const index = enemies.indexOf(this.target);
                    if (index > -1) {
                        enemies.splice(index, 1);
                        gold += 1;
                        updateUI();
                        if (enemies.length === 0) {
                            endRound();
                        }
                    }
                }
                return 'remove';
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#f1c40f';
                ctx.fill();
            }
        }

        // --- LÃ³gica del juego ---

        function generatePath() {
            path = [];
            let currentX = 1; // El camino comienza en la columna 1, lejos del borde izquierdo.
            // Iniciar el camino en el centro vertical
            let currentY = Math.floor(GRID_ROWS / 2);
            let pathGrid = new Array(GRID_ROWS).fill(0).map(() => new Array(GRID_COLS).fill(false));

            currentY = Math.max(0, Math.min(GRID_ROWS - 1, currentY));
            pathGrid[currentY][currentX] = true;
            path.push({ x: currentX, y: currentY });

            while (currentX < GRID_COLS - 1) {
                const possibleMoves = [];
                // Derecha
                if (currentX + 1 < GRID_COLS && !pathGrid[currentY][currentX + 1]) {
                    possibleMoves.push({ dx: 1, dy: 0 });
                }
                // Arriba (dentro de los lÃ­mites)
                if (currentY - 1 >= 0 && !pathGrid[currentY - 1][currentX]) {
                    possibleMoves.push({ dx: 0, dy: -1 });
                }
                // Abajo (dentro de los lÃ­mites)
                if (currentY + 1 < GRID_ROWS && !pathGrid[currentY + 1][currentX]) {
                    possibleMoves.push({ dx: 0, dy: 1 });
                }
                
                const move = possibleMoves.find(m => m.dx === 1) || possibleMoves[Math.floor(Math.random() * possibleMoves.length)];

                if (!move) break; // No hay movimientos posibles

                currentX += move.dx;
                currentY += move.dy;
                pathGrid[currentY][currentX] = true;
                path.push({ x: currentX, y: currentY });
            }

            while (currentX < GRID_COLS - 1) {
                currentX++;
                path.push({ x: currentX, y: currentY });
            }
        }
        
        function placeInitialTowers() {
            if (path.length < 4) return; // Asegurar que el camino sea lo suficientemente largo
            
            // Puntos para las torres mÃ¡s cercanas al camino (distribuciÃ³n 25%, 50%, 75%)
            const closeTowerIndices = [
                Math.floor(path.length * 0.25),
                Math.floor(path.length * 0.5),
                Math.floor(path.length * 0.75)
            ];

            // Puntos para las torres mÃ¡s alejadas del camino (distribuciÃ³n 10%, 50%, 90%)
            const farTowerIndices = [
                Math.floor(path.length * 0.1),
                Math.floor(path.length * 0.5),
                Math.floor(path.length * 0.9)
            ];

            // Colocar 3 torres mÃ¡s arriba (fila 2, mÃ¡s separadas) - HÃ©roes 0, 1, 2
            farTowerIndices.forEach((idx, i) => {
                const tile = path[idx];
                towers.push(new Tower(tile.x, tile.y - 3, true, i));
            });

            // Colocar 3 torres arriba (fila 1, mÃ¡s cerca) - HÃ©roes 3, 4, 5
            closeTowerIndices.forEach((idx, i) => {
                const tile = path[idx];
                towers.push(new Tower(tile.x, tile.y - 1, true, i + 3));
            });

            // Colocar 3 torres abajo (fila 1, mÃ¡s cerca) - HÃ©roes 6, 7, 8
            closeTowerIndices.forEach((idx, i) => {
                const tile = path[idx];
                towers.push(new Tower(tile.x, tile.y + 1, false, i + 6));
            });

            // Colocar 3 torres mÃ¡s abajo (fila 2, mÃ¡s separadas) - HÃ©roes 9, 10, 11
            farTowerIndices.forEach((idx, i) => {
                const tile = path[idx];
                towers.push(new Tower(tile.x, tile.y + 3, false, i + 9));
            });
        }

        function spawnEnemies() {
            const numEnemies = round * 3 + 5; // MÃ¡s enemigos cada ronda
            let spawnCount = 0;
            spawnInterval = setInterval(() => {
                if (spawnCount < numEnemies) {
                    if (isPaused) return;
                    enemies.push(new Enemy(path));
                    spawnCount++;
                } else {
                    clearInterval(spawnInterval);
                }
            }, 1000 - (round * 50)); // Reducir el intervalo de spawn
        }

        function startRound() {
            isPaused = false;
            if (pauseBtn) { pauseBtn.disabled = false; pauseBtn.textContent = "Pause Wave"; }
            try { const snd = document.getElementById('arrowSound'); if (snd) { snd.volume = 0.8; snd.play().then(()=>{snd.pause(); snd.currentTime = 0;}).catch(()=>{}); } } catch(e) {}
            if (roundInProgress) return;
            round++;
            roundInProgress = true;
            spawnEnemies();
            updateUI();
            startRoundBtn.disabled = true;
            showMessage(`Wave ${round} has begun!`);
        }

        function endRound() {
            isPaused = false;
            if (pauseBtn) { pauseBtn.disabled = true; pauseBtn.textContent = "Pause Wave"; }
            roundInProgress = false;
            startRoundBtn.disabled = false;
            gold += 1; // Oro de bonificaciÃ³n por ronda
            updateUI();
            showMessage(`Wave ${round} completed! You earn 50 gold.`);
        }

        function gameOver() {
            isPaused = false;
            if (pauseBtn) { pauseBtn.disabled = true; pauseBtn.textContent = "Pause Wave"; }
            isGameOver = true;
            startRoundBtn.disabled = true;
            roundInProgress = false;
            clearInterval(spawnInterval);
            showMessage('Game over! Refresh the page to play again.');
        }

        
        function restartGame() {
            // Clear intervals
            try { clearInterval(spawnInterval); } catch(e) {}
            // Reset state
            gold = 0;
            health = 100;
            round = 0;
            roundInProgress = false;
            isGameOver = false;
            isPaused = false;
            // Reset arrays
            towers = [];
            enemies = [];
            projectiles = [];
            // Rebuild path and towers
            generatePath();
            placeInitialTowers();
            updateUI();
            // Buttons
            startRoundBtn.disabled = false;
            if (typeof pauseBtn !== 'undefined' && pauseBtn) { pauseBtn.disabled = true; pauseBtn.textContent = 'Pause Wave'; }
            showMessage('Game restarted. Press "Start Wave" to play.');
        }

        function updateUI() {
            goldValueEl.textContent = gold;
            healthValueEl.textContent = health;
            roundValueEl.textContent = round;
        }

        function showMessage(message) {
            gameMessagesEl.textContent = message;
            setTimeout(() => {
                gameMessagesEl.textContent = '';
            }, 3000);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar el camino
            ctx.fillStyle = '#95a5a6'; // Gris
            path.forEach(tile => {
                ctx.fillRect(tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // Dibujar el punto de spawn parpadeante
            if (path.length > 0 && Date.now() % 1000 > 500) {
                const spawnTile = path[0];
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 4;
                ctx.strokeRect(spawnTile.x * TILE_SIZE, spawnTile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.lineWidth = 1;
            }
            
            // Dibujar el castillo
            const castleTile = path[path.length - 1];
            ctx.fillStyle = '#c0392b'; // Rojo oscuro
            ctx.fillRect(castleTile.x * TILE_SIZE, castleTile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            
            // Dibujar torres
            towers.forEach(tower => tower.draw());

            // Dibujar proyectiles
            projectiles.forEach(p => p.draw());

            // Dibujar enemigos
            enemies.forEach(enemy => enemy.draw());
        }

        function update() {
            if (isGameOver || isPaused) return;
            enemies.forEach(enemy => enemy.update());
            towers.forEach(tower => tower.update());
            projectiles = projectiles.filter(p => (p.update() !== 'remove'));
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        
        // --- Manejo de Eventos ---
        startRoundBtn.addEventListener('click', startRound);
        restartBtn.addEventListener('click', restartGame);
        
        // Pause/Resume logic
        pauseBtn.addEventListener('click', () => {
            if (isGameOver || !roundInProgress) return;
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause Wave';
        });

        
        // --- InicializaciÃ³n del juego ---
        generatePath();
        placeInitialTowers();
        updateUI();
        loop();
        
        // Mensaje de bienvenida personalizado
        function showWelcomeMessage() {
            if (heroes && heroes.length > 0 && heroes[0].name !== 'Hero1') {
                const heroNames = heroes.map(h => h.name).join(', ');
                showMessage(`Â¡Bienvenido! Tus hÃ©roes ${heroNames} estÃ¡n listos para defender. Presiona "Start Wave" para comenzar.`);
            } else {
                showMessage('Welcome! Your 12 towers are already placed. Press "Start Wave" to begin.');
            }
        }
        
        showWelcomeMessage();
    </script>
</body>
</html>
