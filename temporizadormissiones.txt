# SISTEMA DE TEMPORIZADORES DE MISIONES
================================================================================

## RESUMEN GENERAL

El juego utiliza un sistema de temporizadores centralizado que gestiona todas las 
actividades cronometradas, incluyendo tres tipos de misiones: individuales, 
diarias y grupales.

================================================================================
## 1. MISIONES INDIVIDUALES (MISSIONS)
================================================================================

### Ubicaci√≥n del c√≥digo:
- Inicio: `script.js` ‚Üí funci√≥n `startMission(hero, slot)`
- Procesamiento: `script.js` ‚Üí funci√≥n `processAllTimers()`
- Finalizaci√≥n: `script.js` ‚Üí funci√≥n `finishTimer()` ‚Üí caso 'mission'

### Duraci√≥n seg√∫n dificultad:
Definidas en `src/missions/utils.js` ‚Üí funci√≥n `missionDuration(id)`:

- **Easy**: 1800 segundos (30 minutos)
- **Normal**: 3600 segundos (1 hora)  
- **Hard**: 7200 segundos (2 horas)
- **Misiones especiales**:
  - IDs 4, 11: 43200 segundos (12 horas)
  - IDs 10, 12: 28800 segundos (8 horas)
  - IDs 16, 18, 20: 10800 segundos (3 horas)

### Proceso de inicio:
```javascript
function startMission(hero, slot) {
  const duration = missionDuration(slot.id);  // En segundos
  const now = Date.now();
  
  // Registrar en el h√©roe
  hero.missionTime = duration;
  hero.missionDuration = duration;
  hero.missionStartTime = now;
  
  // Asignar h√©roe al slot
  slot.heroId = hero.id;
  
  // Crear temporizador
  addTimer({
    id: `mission_${slot.id}`,
    type: 'mission',
    heroId: hero.id,
    slotId: slot.id,
    startTime: now,
    duration: duration * 1000,  // Convertir a milisegundos
    paused: false,
    completed: false
  });
}
```

### Proceso de verificaci√≥n:
**IMPORTANTE**: El sistema verifica los temporizadores cada **60 segundos** (MIN).

```javascript
// En script.js, l√≠nea ~1896-1901
setInterval(() => {
  if (!document.hidden) {
    processAllTimers(Date.now());
    updateConstructionOverlays();
  }
}, MIN);  // MIN = 60000 ms (60 segundos)
```

### Proceso de finalizaci√≥n:
Cuando `elapsed >= timer.duration`, se ejecuta `finishTimer()`:

```javascript
case 'mission': {
  const hero = getHeroById(timer.heroId);
  const slot = state.missions.find(m => m.id === timer.slotId);
  
  if (hero && slot) {
    // Marcar como completada
    slot.completed = true;
    
    // Aplicar recompensas
    state.money += slot.expReward;
    addHeroExp(hero, slot.expReward);
    
    // Reducir energ√≠a del h√©roe
    const energyLoss = missionEnergyCost(slot.id);
    hero.energia = Math.max(0, hero.energia - energyLoss);
    
    // Auto-iniciar descanso si es necesario
    autoStartRest(hero);
    
    // Limpiar estado del h√©roe
    hero.missionTime = 0;
    hero.missionStartTime = 0;
    hero.missionDuration = 0;
    
    // Actualizar interfaz
    renderMissions();
    renderHeroesIfVisible();
  }
}
```

================================================================================
## 2. MISIONES DIARIAS (DAILY MISSIONS)
================================================================================

### Ubicaci√≥n del c√≥digo:
- Inicio: `src/dailyMissions.js` ‚Üí funci√≥n `startDailyMission(hero, slot)`
- Procesamiento: Igual que misiones individuales
- Finalizaci√≥n: `script.js` ‚Üí funci√≥n `finishTimer()` ‚Üí caso 'dailyMission'

### Duraci√≥n:
- **Fija**: 21600 segundos (6 horas)

### Caracter√≠sticas especiales:
- Se regeneran por semana (no por d√≠a)
- Usan la clave de semana: `slot.assignedWeek = getWeekKey(new Date())`
- Al completarse:
  - Se marca `slot.completed = true`
  - Se guarda `slot.completedWeek`
  - Se guarda `slot.completedHeroId`
  - Se libera el h√©roe: `slot.heroId = null`

### Recompensas:
- Gold: 5000
- EXP: 5000
- P√©rdida de energ√≠a: 50%

================================================================================
## 3. MISIONES GRUPALES (GROUP MISSIONS)
================================================================================

### Ubicaci√≥n del c√≥digo:
- Inicio: `script.js` ‚Üí funci√≥n an√≥nima en evento click de "Start"
- Procesamiento: `script.js` ‚Üí funci√≥n `tickGroupMissions()`
- Finalizaci√≥n: Dentro de `tickGroupMissions()`

### Duraci√≥n:
```javascript
const GM_DURATION_MS = 8 * 60 * 60 * 1000;  // 8 horas (28,800,000 ms)
```

### Sistema de verificaci√≥n DIFERENTE:
**CR√çTICO**: Las group missions NO usan el sistema de `processAllTimers()`.
En su lugar, tienen su propio ticker:

```javascript
// Ejecutado al iniciar el juego
tickGroupMissions();
setInterval(tickGroupMissions, 60 * MIN);  // Cada 60 minutos
```

**Frecuencia de verificaci√≥n**: Cada **60 minutos** (3,600,000 ms)

### Proceso de inicio:
```javascript
// Al hacer click en "Start"
gm.started = true;
gm.status = 'running';
gm.startAt = Date.now();
gm.endAt = gm.startAt + GM_DURATION_MS;  // +8 horas
gm.rewardApplied = false;
```

### Proceso de verificaci√≥n y finalizaci√≥n:
```javascript
function tickGroupMissions() {
  const now = Date.now();
  
  for (const m of (state.groupMissions || [])) {
    if (m.status === 'running' && m.endAt && now >= m.endAt) {
      // Cambiar estado a completado
      m.status = 'completed';
      m.started = false;
      
      // Restaurar energ√≠a de los h√©roes
      for (const id of m.heroIds.filter(Boolean)) {
        const h = getAllHeroes().find(x => 
          (x.id != null ? String(x.id) : x.name) === id
        );
        if (h) {
          h.energyPercent = 100;
          h.energy = 100;
          h.stamina = 100;
          h.energia = 100;
        }
      }
      
      // NO se aplica recompensa autom√°ticamente
      // NO se liberan los h√©roes hasta recolectar
      
      saveGame?.();
    }
  }
  
  // Actualizar interfaz si est√° visible
  if (document.getElementById('group-mission-grid')) {
    renderGroupMissions();
  }
}
```

### Recolecci√≥n de recompensas:
- Manual: El usuario debe hacer click en "Collect Rewards"
- C√°lculo: `GM_BASE_REWARD` (10,000) con posibles bonos
- Bonos:
  - **Same Origin Bonus**: +100% si los 5 h√©roes son del mismo origen
  - **Promedio de niveles**: Influye en la recompensa final

================================================================================
## 4. AN√ÅLISIS DEL PROBLEMA: "Misi√≥n de 30 minutos no se complet√≥"
================================================================================

### Causa probable:
El sistema tiene diferentes frecuencias de verificaci√≥n:

1. **Misiones individuales y diarias**:
   - Se verifican cada **60 segundos**
   - Una misi√≥n de 30 minutos (1800 segundos) se verifica ~30 veces
   - DEBE completarse correctamente

2. **Group Missions**:
   - Se verifican cada **60 MINUTOS**
   - Una misi√≥n de 8 horas necesita al menos 9 verificaciones
   - Puede haber retraso de hasta 59 minutos en marcarla como completada

### Posibles causas de fallo:

#### A) Tab oculta/inactiva:
```javascript
setInterval(() => {
  if (!document.hidden) {  // ‚Üê Solo procesa si el tab est√° visible
    processAllTimers(Date.now());
  }
}, MIN);
```
**Soluci√≥n**: Al volver visible, se ejecuta `processAllTimers()` una vez:
```javascript
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) processAllTimers(Date.now());
});
```

#### B) Minigame activo:
```javascript
function processAllTimers(now = Date.now()) {
  if (timersPaused) return;  // ‚Üê Si los timers est√°n pausados
  
  for (const timer of activeTimers) {
    if (isMinigameActive || timer.completed) continue;  // ‚Üê Salta si hay minigame
    // ...
  }
}
```

#### C) Timer marcado como completed pero slot no actualizado:
Si el timer se marc√≥ como `completed` pero hubo un error en `finishTimer()`.

#### D) Estado desincronizado:
El h√©roe tiene `missionTime > 0` pero no hay timer activo para √©l.

### Sistema de correcci√≥n autom√°tica:
```javascript
// Cada 3 minutos (l√≠nea ~1903-1946)
setInterval(() => {
  if (document.hidden) return;
  
  // Corrige h√©roes con estado bloqueado
  state.heroes.forEach(h => {
    const inactive =
      h.missionTime <= 0 &&
      h.collectTime <= 0 &&
      // ... otras actividades
      h.restTime <= 0;
    
    if (h.energia >= 97 && h.energia < 100 && inactive) {
      h.energia = 100;
      // ...
    }
  });
}, 3 * MIN);
```

================================================================================
## 5. CONSTANTES DE TIEMPO (src/utils/timerConstants.js)
================================================================================

```javascript
export const MIN = 60_000;        // 1 minuto en milisegundos
export const HOUR = 60 * MIN;     // 1 hora
export const HALF_HOUR = 30 * MIN; // 30 minutos

export const TIMER_INTERVALS = {
  MAIN_GAME: MIN,               // 60,000 ms - Timer principal
  SPECIAL_BUILDER: HOUR,        // 3,600,000 ms - Special builders
  GROUP_MISSIONS: HALF_HOUR,    // 1,800,000 ms - NOTA: No usado actualmente
  HERO_CORRECTION: MIN,         // 60,000 ms - Correcci√≥n de h√©roes
  BUILD_STATUS_CLEANUP: 3 * MIN, // 180,000 ms - Limpieza de construcci√≥n
};
```

**NOTA IMPORTANTE**: Aunque `TIMER_INTERVALS.GROUP_MISSIONS = HALF_HOUR`, 
el c√≥digo real usa `60 * MIN` (1 hora) para las group missions.

================================================================================
## 6. RECOMENDACIONES Y SOLUCIONES
================================================================================

### Para depurar una misi√≥n que no se completa:

1. **Verificar el estado del timer en consola**:
```javascript
// En la consola del navegador
activeTimers.forEach(t => console.log(t));
```

2. **Verificar el estado del h√©roe**:
```javascript
// Encontrar el h√©roe
const hero = state.heroes.find(h => h.name === "NombreDelH√©roe");
console.log({
  missionTime: hero.missionTime,
  missionStartTime: hero.missionStartTime,
  missionDuration: hero.missionDuration
});
```

3. **Verificar el slot de la misi√≥n**:
```javascript
const slot = state.missions.find(m => m.heroId === hero.id);
console.log(slot);
```

4. **Forzar verificaci√≥n manual**:
```javascript
processAllTimers(Date.now());
```

5. **Para Group Missions**:
```javascript
tickGroupMissions();
```

### Posibles mejoras al sistema:

1. **Unificar frecuencia de verificaci√≥n**:
   - Cambiar group missions de 60 minutos a 1 minuto

2. **Mejorar manejo de tab oculta**:
   - Guardar tiempo transcurrido y aplicarlo al volver
   
3. **Agregar logs de depuraci√≥n**:
   - Registrar cu√°ndo se inicia/completa cada misi√≥n
   
4. **Agregar validaci√≥n de consistencia**:
   - Verificar que exista timer para cada misi√≥n activa
   - Verificar que exista misi√≥n activa para cada timer de misi√≥n

================================================================================
## 7. FLUJO COMPLETO DE UNA MISI√ìN DE 30 MINUTOS
================================================================================

### Timeline esperado:

**T=0s (Inicio)**
1. Usuario hace click en "Start Mission"
2. `startMission(hero, slot)` se ejecuta
3. Se crea timer con `duration: 1800 * 1000` (30 minutos en ms)
4. `hero.missionTime = 1800`
5. `hero.missionStartTime = Date.now()`

**T=60s (Primera verificaci√≥n)**
1. `processAllTimers()` se ejecuta
2. Calcula `elapsed = now - timer.startTime` (‚âà60,000 ms)
3. Como `elapsed < duration`, no hace nada
4. Actualiza contador en pantalla (si visible)

**T=120s - 1740s (Verificaciones intermedias)**
- Cada 60 segundos, `processAllTimers()` verifica
- `hero.missionTime` se actualiza en la UI

**T=1800s (30 minutos - Completada)**
1. `processAllTimers()` detecta `elapsed >= duration`
2. Ejecuta `finishTimer(timer)`
3. En el caso 'mission':
   - `slot.completed = true`
   - Aplica recompensas (gold + exp)
   - Reduce energ√≠a del h√©roe
   - Limpia `hero.missionTime = 0`
   - Llama a `renderMissions()` para actualizar UI
4. El slot ahora muestra "Collect Rewards"

**T=1860s (Si el usuario no estaba mirando)**
- La siguiente verificaci√≥n (a los 1860s) ya encuentra
  `timer.completed = true` y lo salta
- La UI se actualiza la pr√≥xima vez que se renderice

================================================================================
## 8. AN√ÅLISIS COMPARATIVO: MISIONES vs SPECIAL BUILDER ASSIGNMENT
================================================================================

### PREGUNTA CLAVE:
¬øSe guarda el momento exacto en que se inici√≥ una misi√≥n para calcular correctamente 
la finalizaci√≥n? Por ejemplo, si una misi√≥n de 30 minutos empez√≥ a las 16:15, 
¬øel sistema garantiza que estar√° completada a las 16:45?

### RESPUESTA: S√ç, ambos sistemas guardan timestamps, pero con diferencias importantes

================================================================================
### A) SPECIAL BUILDER ASSIGNMENT (Sistema de referencia - FUNCIONA BIEN)
================================================================================

#### Ubicaci√≥n: `src/specialBuilderAssignment.js`

#### C√≥mo guarda el tiempo:
```javascript
function assignHeroToSlot(slotId, heroId) {
  const cfg = SLOT_CONFIG.find(c => c.slotId === slotId);
  let durationMs = cfg.baseHours * 60 * 60 * 1000;  // 1H, 2H, 4H u 8H
  
  // Si el h√©roe es builder, reduce duraci√≥n a la mitad
  if (hero.professions && hero.professions.some(p => p.toLowerCase() === 'builder')) {
    durationMs /= 2;
  }
  
  const slot = slots.find(s => s.slotId === slotId);
  slot.assignedHeroId = id;
  slot.startedAt = new Date().toISOString();  // ‚Üê ISO STRING (ej: "2024-01-15T16:15:00.000Z")
  slot.durationMs = durationMs;                // ‚Üê Duraci√≥n en milisegundos
  slot.status = 'running';
  
  saveSlots();  // Guarda inmediatamente en localStorage
}
```

#### C√≥mo verifica la finalizaci√≥n:
```javascript
function checkSlots() {
  const now = Date.now();  // Timestamp actual
  let changed = false;
  
  slots.forEach(s => {
    if (s.status === 'running' && s.startedAt) {
      // Calcula el momento exacto de finalizaci√≥n
      const end = Date.parse(s.startedAt) + s.durationMs;
      
      // Compara si ya pas√≥ ese momento
      if (end <= now) {
        s.status = 'completed';
        changed = true;
      }
    }
  });
  
  if (changed) {
    saveSlots();
    renderSection();
  }
}

// Se ejecuta cada 1 HORA
setInterval(checkSlots, 3_600_000);
```

#### Caracter√≠sticas:
‚úÖ **Guarda ISO string** con fecha y hora exacta
‚úÖ **Calcula tiempo de fin** = startedAt + durationMs
‚úÖ **Comparaci√≥n absoluta**: compara `end <= now`
‚úÖ **Persistencia**: Se guarda en `localStorage['specialBuilderSlots']`
‚úÖ **Restauraci√≥n**: Al cargar el juego, lee los slots del localStorage
‚úÖ **Independiente**: NO depende del sistema de timers centralizados

#### Ejemplo pr√°ctico:
```
Inicio: 15 Ene 2024 16:15:00 ‚Üí slot.startedAt = "2024-01-15T16:15:00.000Z"
Duraci√≥n: 2 horas ‚Üí slot.durationMs = 7_200_000 ms
Fin calculado: Date.parse("2024-01-15T16:15:00.000Z") + 7_200_000
             = 1705337700000 + 7_200_000
             = 1705344900000
             = 15 Ene 2024 18:15:00

Verificaci√≥n (cada hora):
- 16:00 ‚Üí now < end ‚Üí a√∫n corriendo
- 17:00 ‚Üí now < end ‚Üí a√∫n corriendo
- 18:00 ‚Üí now < end ‚Üí a√∫n corriendo (falta 15 min)
- 19:00 ‚Üí now >= end ‚Üí ¬°COMPLETADA!
```

**VENTAJA**: Aunque se verifique solo cada hora, la comparaci√≥n es absoluta contra 
el momento de fin, por lo que SIEMPRE se marca como completada en la primera 
verificaci√≥n despu√©s de las 18:15.

================================================================================
### B) MISIONES INDIVIDUALES (Sistema con posibles problemas)
================================================================================

#### Ubicaci√≥n: `script.js` ‚Üí funci√≥n `startMission()`

#### C√≥mo guarda el tiempo:
```javascript
export function startMission(hero, slot) {
  const duration = missionDuration(slot.id);  // En SEGUNDOS (ej: 1800 para 30 min)
  const now = Date.now();  // Timestamp num√©rico (ej: 1705337700000)
  
  // TRIPLE REGISTRO del tiempo:
  // 1. En el h√©roe
  hero.missionTime = duration;           // Tiempo restante en segundos
  hero.missionDuration = duration;       // Duraci√≥n total en segundos
  hero.missionStartTime = now;           // ‚Üê TIMESTAMP NUM√âRICO (momento exacto)
  
  // 2. En el slot
  slot.heroId = hero.id;
  
  // 3. En el timer centralizado
  addTimer({
    id: `mission_${slot.id}`,
    type: 'mission',
    heroId: hero.id,
    slotId: slot.id,
    startTime: now,                      // ‚Üê TIMESTAMP NUM√âRICO (momento exacto)
    duration: duration * 1000,           // ‚Üê Duraci√≥n en MILISEGUNDOS
    paused: false,
    completed: false
  });
}
```

#### C√≥mo verifica la finalizaci√≥n:
```javascript
function processAllTimers(now = Date.now()) {
  if (timersPaused) return;
  
  for (const timer of activeTimers) {
    if (isMinigameActive || timer.completed) continue;
    
    // Calcula tiempo transcurrido
    const elapsed = now - timer.startTime;
    
    // Actualiza contador en el h√©roe (solo para UI)
    if (timer.type === 'mission') {
      const hero = getHeroById(timer.heroId);
      if (hero) {
        const totalElapsed = Math.floor((now - hero.missionStartTime) / 1000);
        hero.missionTime = Math.max(0, hero.missionDuration - totalElapsed);
      }
    }
    
    // Verifica si ya termin√≥
    if (elapsed >= timer.duration) {
      finishTimer(timer);      // Aplica recompensas
      timer.completed = true;  // Marca como completado
      changed = true;
    }
  }
  
  // Limpia timers completados
  if (changed) {
    activeTimers = activeTimers.filter(t => !t.completed);
    saveTimers();
    scheduleSaveGame();
  }
}

// Se ejecuta cada 60 SEGUNDOS
setInterval(() => {
  if (!document.hidden) {
    processAllTimers(Date.now());
  }
}, MIN);  // MIN = 60_000 ms
```

#### Caracter√≠sticas:
‚úÖ **Guarda timestamp num√©rico** (Date.now()) en `hero.missionStartTime` y `timer.startTime`
‚úÖ **Calcula tiempo transcurrido** = now - startTime
‚úÖ **Comparaci√≥n relativa**: compara `elapsed >= duration`
‚ö†Ô∏è **Doble persistencia**: 
   - Estado del h√©roe en `localStorage['gameState']`
   - Timer en `localStorage['activeTimers']`
‚ö†Ô∏è **Dependencia cr√≠tica**: El timer DEBE existir en `activeTimers`
‚ö†Ô∏è **Restauraci√≥n compleja**: Al recargar, debe sincronizar hero + timer

#### Ejemplo pr√°ctico:
```
Inicio: 15 Ene 2024 16:15:00
  hero.missionStartTime = 1705337700000
  timer.startTime = 1705337700000
  timer.duration = 1_800_000 (30 minutos en ms)

Verificaci√≥n cada 60 segundos:
- 16:16:00 ‚Üí elapsed = 60,000 ms < 1,800,000 ‚Üí contin√∫a
- 16:17:00 ‚Üí elapsed = 120,000 ms < 1,800,000 ‚Üí contin√∫a
- ...
- 16:44:00 ‚Üí elapsed = 1,740,000 ms < 1,800,000 ‚Üí contin√∫a
- 16:45:00 ‚Üí elapsed = 1,800,000 ms >= 1,800,000 ‚Üí ¬°COMPLETADA!
- 16:46:00 ‚Üí elapsed = 1,860,000 ms >= 1,800,000 ‚Üí ya completada
```

**VENTAJA**: Alta precisi√≥n (verifica cada 60 segundos vs 1 hora).

**DESVENTAJA**: M√°s puntos de fallo potencial.

================================================================================
### C) PROBLEMAS POTENCIALES DEL SISTEMA DE MISIONES
================================================================================

#### 1. DESINCRONIZACI√ìN TIMER-H√âROE
**Escenario**: El timer se pierde pero el h√©roe mantiene missionTime > 0

```javascript
// Validaci√≥n que existe (l√≠nea ~980-1002):
activeTimers = activeTimers.filter(t => {
  if (t.type === 'mission') {
    const hero = state.heroes.find(h => h.id === t.heroId);
    const slot = state.missions.find(m => m.id === t.slotId && m.heroId === t.heroId);
    return hero && hero.missionTime > 0 && slot;  // ‚Üê Si no hay h√©roe/slot, elimina el timer
  }
  // ...
});

// Limpieza inversa (l√≠nea ~993-1002):
state.heroes.forEach(h => {
  if (
    h.missionTime > 0 &&
    !state.missions.some(m => m.heroId === h.id) &&
    !Object.values(state.dailyMissions).some(arr => arr.some(m => m.heroId === h.id))
  ) {
    // H√©roe tiene missionTime pero no hay slot asociado ‚Üí limpiar
    h.missionTime = 0;
    h.missionStartTime = 0;
    h.missionDuration = 0;
    h.state = { type: 'ready' };
  }
});
```

**Problema**: Si el timer se borra de `localStorage['activeTimers']` por cualquier 
motivo (error, corrupci√≥n, limpieza manual), el sistema lo detecta y limpia al 
h√©roe, pero la misi√≥n puede quedar en estado inconsistente.

#### 2. TAB OCULTA DURANTE LA DURACI√ìN COMPLETA
**Escenario**: Usuario inicia misi√≥n de 30 minutos a las 16:15, cierra/oculta el 
tab, y lo vuelve a abrir a las 17:00.

```javascript
setInterval(() => {
  if (!document.hidden) {  // ‚Üê Solo procesa si el tab est√° visible
    processAllTimers(Date.now());
  }
}, MIN);
```

**Soluci√≥n implementada**:
```javascript
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) processAllTimers(Date.now());
});
```

Cuando el tab vuelve a ser visible, se ejecuta `processAllTimers()` una vez, 
calculando `elapsed = now - timer.startTime`, que ser√° >= 45 minutos (2,700,000 ms), 
por lo que se completar√° inmediatamente.

**RESULTADO**: ‚úÖ Deber√≠a funcionar correctamente.

#### 3. CIERRE DEL NAVEGADOR SIN GUARDAR
**Escenario**: Usuario inicia misi√≥n, el navegador crashea antes de que se ejecute 
`saveTimers()`.

**Problema**: El timer se guarda inmediatamente en `addTimer()`:
```javascript
export function addTimer(timer) {
  activeTimers.push(timer);
  saveTimers();  // ‚Üê Guarda inmediatamente
}
```

Pero el estado del h√©roe se guarda despu√©s:
```javascript
export function startMission(hero, slot) {
  // ... modifica hero y slot ...
  addTimer({ ... });  // ‚Üê Guarda timer inmediatamente
  
  scheduleRenderHeroes();
  setTimeout(() => {
    renderMissions();
  }, 0);
}

// El saveGame() se ejecuta m√°s tarde, posiblemente 200ms despu√©s
export function scheduleSaveGame() {
  saveTimeout = setTimeout(() => {
    saveGame();
  }, 200);
}
```

**Riesgo**: Si el navegador se cierra entre `addTimer()` y `saveGame()`, el timer 
existe en localStorage pero el h√©roe no tiene missionStartTime guardado.

**Al recargar**: La validaci√≥n lo detectar√° y limpiar√° el timer hu√©rfano.

#### 4. MINIGAME ACTIVO
```javascript
function processAllTimers(now = Date.now()) {
  for (const timer of activeTimers) {
    if (isMinigameActive || timer.completed) continue;  // ‚Üê Salta si hay minigame
    // ...
  }
}
```

**Problema**: Si un minigame est√° activo, NO se procesan los timers.

**Impacto**: La verificaci√≥n se retrasa hasta que el minigame termine. El c√°lculo 
sigue siendo correcto porque usa `elapsed = now - timer.startTime`, que considera 
el tiempo real transcurrido independientemente de cu√°ndo se verifique.

**RESULTADO**: ‚úÖ No hay problema real, solo retraso en actualizar la UI.

================================================================================
### D) TABLA COMPARATIVA
================================================================================

| Caracter√≠stica              | Special Builder          | Misiones Individuales    |
|-----------------------------|--------------------------|--------------------------|
| **Formato de timestamp**    | ISO String               | Num√©rico (ms desde epoch)|
| **D√≥nde se guarda**         | localStorage['special    | localStorage['gameState']|
|                             | BuilderSlots']           | + ['activeTimers']       |
| **C√°lculo de finalizaci√≥n** | end = start + duration   | elapsed = now - start    |
| **Frecuencia verificaci√≥n** | Cada 60 minutos          | Cada 60 segundos         |
| **Precisi√≥n**               | Baja frecuencia, alta    | Alta frecuencia, alta    |
|                             | precisi√≥n en c√°lculo     | precisi√≥n en c√°lculo     |
| **Dependencias**            | Solo el slot             | Timer + Hero + Slot      |
| **Persistencia**            | Un solo objeto           | Dos objetos separados    |
| **Restauraci√≥n**            | Simple: lee slots        | Compleja: sincroniza     |
|                             | y verifica               | timer con hero/slot      |
| **Validaci√≥n de consistencia** | No necesaria          | S√≠, limpia hu√©rfanos     |
| **Afectado por tab oculta** | NO (c√°lculo absoluto)    | S√ç (pero con soluci√≥n)   |
| **Afectado por minigames**  | NO                       | S√ç (pero sin impacto real)|

================================================================================
### E) CONCLUSI√ìN: ¬øPOR QU√â UNA MISI√ìN DE 30 MINUTOS PODR√çA NO COMPLETARSE?
================================================================================

**Matem√°ticamente, el sistema es CORRECTO**:
- Guarda el timestamp exacto de inicio
- Calcula elapsed = now - startTime
- Compara elapsed >= duration
- Se verifica cada 60 segundos (suficiente para una misi√≥n de 30 minutos)

**PERO existen condiciones que pueden causar fallos**:

1. **Timer perdido**: Si `localStorage['activeTimers']` se corrompe o borra
   ‚Üí El sistema lo detecta y limpia al h√©roe, pero puede confundir al usuario

2. **Tab siempre oculta + error en visibilitychange**: Si el tab est√° oculto 
   durante toda la duraci√≥n Y el evento visibilitychange no se dispara al volver
   ‚Üí La misi√≥n nunca se verifica

3. **Error de JavaScript**: Si hay un error no capturado en `processAllTimers()`,
   ese ciclo de 60 segundos se salta
   ‚Üí La siguiente verificaci√≥n ser√° en 60 segundos m√°s

4. **Navegador congelado**: Si el navegador entra en modo de suspensi√≥n profunda,
   el setInterval puede no ejecutarse
   ‚Üí Al despertar, deber√≠a compensar con el c√°lculo elapsed

5. **Diferencia de reloj**: Si el usuario cambia la hora del sistema mientras
   la misi√≥n corre, el c√°lculo se afecta
   ‚Üí Podr√≠a completarse antes o despu√©s de lo esperado

================================================================================
### F) RECOMENDACIONES PARA MEJORAR LA ROBUSTEZ
================================================================================

#### 1. Adoptar el modelo de Special Builder Assignment
```javascript
// En lugar de:
timer.startTime = now;
timer.duration = duration * 1000;

// Usar:
timer.startedAt = new Date().toISOString();  // ‚Üê ISO string
timer.endAt = new Date(now + duration * 1000).toISOString();

// Al verificar:
const end = Date.parse(timer.endAt);
if (Date.now() >= end) {
  // completar
}
```

**Ventaja**: M√°s claro y expl√≠cito. Puedes ver exactamente cu√°ndo debe terminar.

#### 2. Unificar la persistencia
```javascript
// Guardar todo en el mismo lugar
slot.startedAt = new Date().toISOString();
slot.endAt = new Date(now + duration * 1000).toISOString();
slot.status = 'running';
// NO crear timer separado en localStorage
```

**Ventaja**: Elimina desincronizaci√≥n entre timer y slot.

#### 3. Agregar timestamps de "√∫ltima verificaci√≥n"
```javascript
timer.lastChecked = Date.now();

// Al verificar:
const timeSinceLastCheck = now - timer.lastChecked;
if (timeSinceLastCheck > 5 * MIN) {
  console.warn(`Timer ${timer.id} no verificado en ${timeSinceLastCheck}ms`);
}
timer.lastChecked = now;
```

**Ventaja**: Detectar si el sistema de verificaci√≥n se atasc√≥.

#### 4. Agregar verificaci√≥n al cargar el juego
```javascript
async function loadGame() {
  // ... cargar datos ...
  
  // Verificar misiones inmediatamente
  processAllTimers(Date.now());
  
  // Esto asegura que misiones que debieron completarse 
  // mientras el juego estaba cerrado se completen al abrir
}
```

#### 5. Logs de depuraci√≥n
```javascript
export function startMission(hero, slot) {
  const now = Date.now();
  const endAt = now + duration * 1000;
  
  console.log(`[MISSION START] Hero: ${hero.name}, Duration: ${duration}s, 
    Start: ${new Date(now).toISOString()}, 
    End: ${new Date(endAt).toISOString()}`);
  
  // ... resto del c√≥digo ...
}

function finishTimer(timer) {
  if (timer.type === 'mission') {
    const now = Date.now();
    const elapsed = now - timer.startTime;
    console.log(`[MISSION COMPLETE] Timer: ${timer.id}, 
      Elapsed: ${(elapsed/1000).toFixed(0)}s, 
      Expected: ${(timer.duration/1000).toFixed(0)}s`);
  }
  // ... resto del c√≥digo ...
}
```

**Ventaja**: Puedes rastrear exactamente qu√© pas√≥ con una misi√≥n espec√≠fica.

================================================================================
NOTA FINAL ACTUALIZADA
================================================================================

**RESPUESTA A LA PREGUNTA DEL USUARIO**:

‚úÖ **S√ç**, el sistema guarda el momento exacto de inicio de las misiones:
- `hero.missionStartTime = Date.now()` (timestamp num√©rico)
- `timer.startTime = Date.now()` (timestamp num√©rico)

‚úÖ **S√ç**, el c√°lculo es correcto:
- Misi√≥n de 30 minutos iniciada a las 16:15:00
- endAt = 16:15:00 + 1800 segundos = 16:45:00
- El sistema calcula `elapsed = now - startTime`
- Cuando `elapsed >= 1800000 ms`, se completa

‚úÖ **Special Builder Assignment funciona igual**:
- Guarda `slot.startedAt = "2024-01-15T16:15:00.000Z"`
- Guarda `slot.durationMs = 7200000` (2 horas)
- Calcula `end = Date.parse(startedAt) + durationMs`
- Compara `now >= end`

‚ö†Ô∏è **PERO las misiones tienen m√°s puntos de fallo**:
1. Dependen de dos objetos: timer en localStorage + hero en gameState
2. Se verifican solo si el tab est√° visible (con soluci√≥n al volver visible)
3. No se verifican si hay un minigame activo (pero el c√°lculo sigue siendo correcto)
4. Pueden perder sincronizaci√≥n si localStorage se corrompe

üîç **Para depurar una misi√≥n que no se complet√≥**:

```javascript
// 1. Verificar el timer
console.log(activeTimers.filter(t => t.type === 'mission'));

// 2. Verificar el h√©roe
const hero = state.heroes.find(h => h.name === "NombreDelH√©roe");
console.log({
  missionTime: hero.missionTime,
  missionStartTime: hero.missionStartTime,
  missionDuration: hero.missionDuration,
  startedAt: new Date(hero.missionStartTime).toISOString(),
  shouldEndAt: new Date(hero.missionStartTime + hero.missionDuration * 1000).toISOString(),
  now: new Date().toISOString()
});

// 3. Forzar verificaci√≥n
processAllTimers(Date.now());

// 4. Verificar si hay errores en consola
// 5. Verificar si el tab estuvo oculto
```

**El sistema ES matem√°ticamente correcto y DEBER√çA funcionar**, pero tiene m√°s 
complejidad que Special Builder Assignment, lo que aumenta las posibilidades de 
fallos en casos extremos.

================================================================================
## 9. IMPLEMENTACI√ìN DE MEJORAS - ACTUALIZACI√ìN 2024
================================================================================

### ‚úÖ CAMBIOS IMPLEMENTADOS

El sistema de misiones ha sido completamente refactorizado para adoptar el 
modelo de Special Builder Assignment. Los cambios incluyen:

#### 1. Misiones Individuales - Nuevo Modelo

**Ubicaci√≥n**: `script.js` ‚Üí funci√≥n `startMission()`

```javascript
export function startMission(hero, slot) {
  if (isBusy(hero)) return;
  const duration = missionDuration(slot.id); // En segundos
  const now = Date.now();
  const durationMs = duration * 1000;
  
  // ‚úÖ Modelo de Special Builder: timestamps ISO y endAt expl√≠cito
  slot.heroId = hero.id;
  slot.startedAt = new Date(now).toISOString();  // ‚Üê ISO STRING
  slot.endAt = new Date(now + durationMs).toISOString();  // ‚Üê MOMENTO EXACTO DE FIN
  slot.durationMs = durationMs;
  slot.status = 'running';
  
  // Mantener propiedades del h√©roe para compatibilidad con UI
  hero.missionTime = duration;
  hero.missionDuration = duration;
  hero.missionStartTime = now;
  
  scheduleSaveGame();
}
```

**Cambios clave**:
- ‚úÖ `slot.startedAt`: ISO string con fecha y hora exacta
- ‚úÖ `slot.endAt`: Momento exacto de finalizaci√≥n calculado al inicio
- ‚úÖ `slot.status`: Estado expl√≠cito ('running', 'completed')
- ‚úÖ `slot.durationMs`: Duraci√≥n en milisegundos
- ‚ö†Ô∏è NO crea timer en el sistema centralizado

#### 2. Misiones Diarias - Nuevo Modelo

**Ubicaci√≥n**: `src/dailyMissions.js` ‚Üí funci√≥n `startDailyMission()`

```javascript
export function startDailyMission(hero, slot) {
  if (isBusy(hero)) return;
  const duration = 21600; // 6 horas en segundos
  const now = Date.now();
  const durationMs = duration * 1000;
  
  // ‚úÖ Modelo de Special Builder
  slot.heroId = hero.id;
  slot.completedHeroId = null;
  slot.assignedWeek = getWeekKey(new Date());
  slot.startedAt = new Date(now).toISOString();
  slot.endAt = new Date(now + durationMs).toISOString();
  slot.durationMs = durationMs;
  slot.status = 'running';
  
  scheduleSaveGame();
}
```

#### 3. Sistema de Verificaci√≥n Unificado

**Ubicaci√≥n**: `script.js` ‚Üí funci√≥n `checkMissions()`

```javascript
function checkMissions() {
  const now = Date.now();
  let changed = false;
  
  // Verificar misiones individuales
  state.missions.forEach(slot => {
    if (slot.status === 'running' && slot.endAt) {
      const end = Date.parse(slot.endAt);
      const hero = getHeroById(slot.heroId);
      
      if (end <= now) {
        // ‚úÖ Completar misi√≥n usando comparaci√≥n absoluta
        slot.status = 'completed';
        slot.completed = true;
        // ... aplicar recompensas ...
        changed = true;
      } else if (hero) {
        // ‚úÖ Actualizar tiempo restante para la UI
        const remainingMs = end - now;
        hero.missionTime = Math.max(0, Math.ceil(remainingMs / 1000));
      }
    }
  });
  
  // Verificar misiones diarias (l√≥gica similar)
  // ...
}
```

**Caracter√≠sticas**:
- ‚úÖ Comparaci√≥n absoluta: `end <= now`
- ‚úÖ Actualiza tiempo restante cada verificaci√≥n
- ‚úÖ No depende del sistema de timers centralizados
- ‚úÖ Maneja misiones individuales y diarias

#### 4. Funci√≥n Unificada para Todas las Misiones

```javascript
function checkAllMissions() {
  checkMissions();        // Misiones individuales + diarias
  tickGroupMissions();    // Misiones grupales
}

// ‚úÖ Se ejecuta cada 30 MINUTOS (antes 60 seg/60 min)
setInterval(checkAllMissions, 30 * MIN); // 30 * 60_000 = 1_800_000 ms
```

#### 5. Limpieza del Sistema de Timers Centralizados

**Ubicaci√≥n**: `script.js` ‚Üí inicializaci√≥n del estado

```javascript
// Limpiar timers obsoletos
activeTimers = activeTimers.filter(t => {
  // ‚úÖ Eliminar todos los timers de misiones del sistema antiguo
  if (t.type === 'mission' || t.type === 'dailyMission') {
    return false;
  }
  return true;
});
saveTimers();
```

**En `processAllTimers()`**:

```javascript
// ‚úÖ Las misiones ya no se procesan aqu√≠
// Las misiones ahora usan el modelo de Special Builder y se verifican
// cada 30 minutos con checkAllMissions(), no necesitan procesamiento aqu√≠
```

#### 6. Actualizaci√≥n de Group Missions

```javascript
function tickGroupMissions() {
  const now = Date.now();
  let changed = false;
  
  for (const m of (state.groupMissions || [])) {
    if (m.status === 'running' && m.endAt && now >= m.endAt) {
      m.status = 'completed';
      m.started = false;
      // ... restaurar energ√≠a ...
      changed = true;
    }
  }
  
  if (changed) {
    saveGame?.();
    renderGroupMissions();
  }
}

// ‚úÖ Ahora se ejecuta cada 30 minutos (antes 60 minutos)
```

================================================================================
### TABLA COMPARATIVA: ANTES vs DESPU√âS
================================================================================

| Aspecto                   | ANTES                    | DESPU√âS ‚úÖ               |
|---------------------------|--------------------------|--------------------------|
| **Timestamp format**      | Num√©rico (Date.now())    | ISO String               |
| **C√°lculo finalizaci√≥n**  | elapsed = now - start    | end <= now               |
| **Persistencia**          | 2 objetos (timer+hero)   | 1 objeto (slot)          |
| **Verificaci√≥n**          | Cada 60 segundos         | Cada 30 minutos          |
| **Sistema de timers**     | Dependiente              | Independiente ‚úÖ         |
| **Complejidad**           | Alta (m√∫ltiples puntos)  | Baja (modelo simple) ‚úÖ  |
| **Puntos de fallo**       | M√∫ltiples                | M√≠nimos ‚úÖ               |
| **Sincronizaci√≥n**        | Timer + Hero + Slot      | Solo Slot ‚úÖ             |
| **Validaci√≥n hu√©rfanos**  | Necesaria                | No necesaria ‚úÖ          |

================================================================================
### VENTAJAS DEL NUEVO SISTEMA
================================================================================

‚úÖ **1. Simplicidad**
- Un solo objeto (slot) contiene toda la informaci√≥n
- No hay sincronizaci√≥n entre timer y slot
- No hay validaci√≥n de hu√©rfanos

‚úÖ **2. Robustez**
- Comparaci√≥n absoluta contra tiempo de fin
- No depende de verificaciones frecuentes
- Funciona correctamente incluso con tab oculta

‚úÖ **3. Claridad**
- `slot.startedAt` y `slot.endAt` son legibles como strings ISO
- Estado expl√≠cito: `slot.status = 'running' | 'completed'`
- F√°cil de depurar en consola

‚úÖ **4. Eficiencia**
- Verificaci√≥n cada 30 minutos (vs 60 segundos)
- Menos carga de CPU
- Menos actualizaciones del localStorage

‚úÖ **5. Consistencia**
- Mismo modelo para misiones individuales, diarias y grupales
- Mismo patr√≥n que Special Builder Assignment (probado y funcional)
- C√≥digo m√°s mantenible

================================================================================
### MIGRACI√ìN Y COMPATIBILIDAD
================================================================================

El sistema mantiene compatibilidad hacia atr√°s:

```javascript
// Mantener propiedades del h√©roe para compatibilidad con UI
hero.missionTime = duration;
hero.missionDuration = duration;
hero.missionStartTime = now;
```

Esto asegura que:
- La UI existente sigue funcionando
- No se pierden misiones en curso al actualizar
- Los timers antiguos se limpian autom√°ticamente

================================================================================
### VERIFICACI√ìN MANUAL DEL NUEVO SISTEMA
================================================================================

Para verificar que una misi√≥n funciona correctamente:

```javascript
// 1. Ver estado del slot
const slot = state.missions[0]; // Primera misi√≥n
console.log({
  heroId: slot.heroId,
  startedAt: slot.startedAt,      // "2024-01-15T16:15:00.000Z"
  endAt: slot.endAt,              // "2024-01-15T16:45:00.000Z"
  durationMs: slot.durationMs,    // 1800000
  status: slot.status,            // "running" o "completed"
  shouldBeComplete: Date.now() >= Date.parse(slot.endAt)
});

// 2. Forzar verificaci√≥n
checkAllMissions();

// 3. Ver todas las misiones activas
state.missions.filter(s => s.status === 'running')
  .map(s => ({
    id: s.id,
    hero: state.heroMap.get(s.heroId)?.name,
    endsAt: s.endAt,
    timeLeft: Math.ceil((Date.parse(s.endAt) - Date.now()) / 60000) + 'm'
  }));
```

================================================================================
### RESULTADO FINAL
================================================================================

**PREGUNTA ORIGINAL**: 
"¬øUna misi√≥n de 30 minutos iniciada a las 16:15 estar√° completada a las 16:45?"

**RESPUESTA CON EL NUEVO SISTEMA**: 
‚úÖ **S√ç, GARANTIZADO**

1. Al iniciar a las 16:15:00:
   - `slot.startedAt = "2024-01-15T16:15:00.000Z"`
   - `slot.endAt = "2024-01-15T16:45:00.000Z"`
   - `slot.status = 'running'`

2. Primera verificaci√≥n a las 16:30 (despu√©s de 15 min):
   - `Date.parse(slot.endAt) = 1705337100000`
   - `Date.now() ‚âà 1705336200000`
   - `end > now` ‚Üí Sigue corriendo ‚úì

3. Segunda verificaci√≥n a las 17:00 (despu√©s de 45 min):
   - `Date.now() ‚âà 1705339800000`
   - `end <= now` ‚Üí ¬°COMPLETADA! ‚úÖ

**Ventaja**: Aunque la verificaci√≥n se realice cada 30 minutos, la comparaci√≥n 
es contra el tiempo absoluto de finalizaci√≥n, por lo que SIEMPRE se marca como 
completada en la primera verificaci√≥n despu√©s del tiempo objetivo, sin importar 
cu√°nto tiempo haya pasado.

**Comparaci√≥n con Special Builder Assignment**: ‚úÖ ID√âNTICO
Ahora ambos sistemas funcionan exactamente igual, con la misma robustez y confiabilidad.
